<!DOCTYPE html>



<html lang="en">



	<meta charset="UTF-8">

	<meta name="viewport" content="width=device-width, initial-scale=1.0">

	<style>


    .node {

        stroke: #fff;

        stroke-width: 2px;

    }

    

    .link {

        stroke: #777;

        stroke-width: 2px;

    }



</style>

<body>

<a href="https://cortext.io">Cortext Website</a><br>

<a href="https://riskrunners.com">Public Company Risk Factors</a><br>

<a href="https://jefferson.cloud">Jefferson.Cloud</a><br>




    <script src="https://d3js.org/d3.v3.min.js"></script>

    <script>


// set a width and height for our SVG

var width = 3000,


    height = 3000;

    
// setup links

var links =     [
{source: "START_HERE", target: "1: Topological ", fill: "#b31b1b"},
{source: "1: Topological ", target: "1: topological ordering", fill: "#b31b1b"},
{source: "1: topological ordering", target: "1: directed graph", fill: "#b31b1b"},
{source: "1: directed graph", target: "1: linear ordering", fill: "#b31b1b"},
{source: "1: linear ordering", target: "1: every directed edge uv from vertex u", fill: "#b31b1b"},
{source: "1: every directed edge uv from vertex u", target: "1: vertex v u comes", fill: "#b31b1b"},
{source: "1: Topological ", target: "2: graph may represent tasks", fill: "#446ccf"},
{source: "2: graph may represent tasks", target: "2: edges may represent constraints", fill: "#446ccf"},
{source: "2: edges may represent constraints", target: "2: one task must", fill: "#446ccf"},
{source: "2: one task must", target: "2: application", fill: "#446ccf"},
{source: "2: application", target: "2: topological ordering", fill: "#446ccf"},
{source: "2: topological ordering", target: "2: valid sequence", fill: "#446ccf"},
{source: "2: graph may represent tasks", target: "6: Topological ", fill: "#fcc200"},
{source: "6: Topological ", target: "6: applications especially", fill: "#fcc200"},
{source: "6: applications especially", target: "6: ranking problems such as feedback arc set", fill: "#fcc200"},
{source: "6: Topological ", target: "12: application", fill: "#50c878"},
{source: "12: application", target: "12: graph represent", fill: "#50c878"},
{source: "12: graph represent", target: "12: milestones", fill: "#50c878"},
{source: "12: milestones", target: "12: edges represent tasks", fill: "#50c878"},
{source: "12: edges represent tasks", target: "12: between one milestone", fill: "#50c878"},
{source: "12: application", target: "14: computer science applications", fill: "#ed1c24"},
{source: "14: computer science applications", target: "14: instruction scheduling ordering", fill: "#ed1c24"},
{source: "14: instruction scheduling ordering", target: "14: formula cell evaluation", fill: "#ed1c24"},
{source: "14: formula cell evaluation", target: "14: recomputing formula values", fill: "#ed1c24"},
{source: "14: recomputing formula values", target: "14: spreadsheets logic synthesis", fill: "#ed1c24"},
{source: "14: spreadsheets logic synthesis", target: "14: compilation tasks", fill: "#ed1c24"},
{source: "14: compilation tasks", target: "14: makefiles data serialization", fill: "#ed1c24"},
{source: "14: makefiles data serialization", target: "14: resolving symbol dependencies", fill: "#ed1c24"},
{source: "14: computer science applications", target: "16: usual algorithms", fill: "#a7fc00"},
{source: "16: usual algorithms", target: "16: topological sorting", fill: "#a7fc00"},
{source: "16: topological sorting", target: "16: nodes plus", fill: "#a7fc00"},
{source: "16: nodes plus", target: "16: edges asymptotically displaystyle", fill: "#a7fc00"},
{source: "16: usual algorithms", target: "18: quote start nodes quote", fill: "#b5a642"},
{source: "18: quote start nodes quote", target: "18: no incoming edges", fill: "#b5a642"},
{source: "18: no incoming edges", target: "18: insert them into", fill: "#b5a642"},
{source: "18: insert them into", target: "18: at least one such node must", fill: "#b5a642"},
{source: "18: at least one such node must", target: "18: nonempty finite acyclic graph", fill: "#b5a642"},
{source: "18: quote start nodes quote", target: "19: node n from", fill: "#deaa88"},
{source: "19: node n from", target: "19: incoming edges then", fill: "#deaa88"},
{source: "19: incoming edges then", target: "19: edges then", fill: "#deaa88"},
{source: "19: edges then", target: "19: insert m into", fill: "#deaa88"},
{source: "19: insert m into", target: "19: no other Sif ", fill: "#deaa88"},
{source: "19: no other Sif ", target: "19: topologically", fill: "#deaa88"},
{source: "19: topologically", target: "19: in the L ", fill: "#deaa88"},
{source: "19: in the L ", target: "19: necessarily unique", fill: "#deaa88"},
{source: "19: node n from", target: "20: Otherwise ", fill: "#007ba7"},
{source: "20: Otherwise ", target: "21: Reflecting ", fill: "#f0f"},
{source: "21: Reflecting ", target: "21: nonuniqueness", fill: "#f0f"},
{source: "21: nonuniqueness", target: "21: of the S ", fill: "#f0f"},
{source: "21: Reflecting ", target: "23: breaks ties lexicographically forms", fill: "#ffcba4"},
{source: "23: breaks ties lexicographically forms", target: "23: CoffmanGraham ", fill: "#ffcba4"},
{source: "23: CoffmanGraham ", target: "23: parallel scheduling", fill: "#ffcba4"},
{source: "23: parallel scheduling", target: "23: layered graph drawing", fill: "#ffcba4"},
{source: "23: breaks ties lexicographically forms", target: "25: algorithm loops through each node", fill: "#008b8b"},
{source: "25: algorithm loops through each node", target: "25: arbitrary", fill: "#008b8b"},
{source: "25: arbitrary", target: "25: already been visited since", fill: "#008b8b"},
{source: "25: already been visited since", target: "25: no outgoing edges ie", fill: "#008b8b"},
{source: "25: no outgoing edges ie", target: "25: leaf nodeL", fill: "#008b8b"},
{source: "25: leaf nodeL", target: "25: will contain", fill: "#008b8b"},
{source: "25: will contain", target: "25: nodes without", fill: "#008b8b"},
{source: "25: nodes without", target: "25: unmarked node n", fill: "#008b8b"},
{source: "25: unmarked node n", target: "25: at least one cycle", fill: "#008b8b"},
{source: "25: at least one cycle", target: "25: each node m with", fill: "#008b8b"},
{source: "25: each node m with", target: "25: edge from n", fill: "#008b8b"},
{source: "25: edge from n", target: "25: output list", fill: "#008b8b"},
{source: "25: output list", target: "25: depend on n", fill: "#008b8b"},
{source: "25: depend on n", target: "25: descendants", fill: "#008b8b"},
{source: "25: algorithm loops through each node", target: "26: Specifically ", fill: "#996515"},
{source: "26: Specifically ", target: "26: algorithm adds node n", fill: "#996515"},
{source: "26: algorithm adds node n", target: "26: depend on n", fill: "#996515"},
{source: "26: depend on n", target: "26: output list", fill: "#996515"},
{source: "26: output list", target: "26: either by", fill: "#996515"},
{source: "26: either by", target: "26: recursive call", fill: "#996515"},
{source: "26: recursive call", target: "26: started even", fill: "#996515"},
{source: "26: Specifically ", target: "31: repeatedly square", fill: "#cc4e5c"},
{source: "31: repeatedly square", target: "31: adjacency matrix", fill: "#cc4e5c"},
{source: "31: adjacency matrix", target: "31: given graph logarithmically", fill: "#cc4e5c"},
{source: "31: given graph logarithmically", target: "31: minimization", fill: "#cc4e5c"},
{source: "31: repeatedly square", target: "32: matrix describes", fill: "#d7837f"},
{source: "32: matrix describes", target: "32: longest path distances", fill: "#d7837f"},
{source: "32: matrix describes", target: "34: Kahn for a DAG ", fill: "#faf0e6"},
{source: "34: Kahn for a DAG ", target: "34: displaystyle", fill: "#faf0e6"},
{source: "34: Kahn for a DAG ", target: "39: initializes", fill: "#e9967a"},
{source: "39: initializes", target: "39: local vertices displaystyle", fill: "#e9967a"},
{source: "39: local vertices displaystyle", target: "39: upper index represents", fill: "#e9967a"},
{source: "39: upper index represents", target: "39: current iteration", fill: "#e9967a"},
{source: "39: initializes", target: "41: global index", fill: "#a40000"},
{source: "41: global index", target: "41: each vertex", fill: "#a40000"},
{source: "41: each vertex", target: "41: prefix sum", fill: "#a40000"},
{source: "41: prefix sum", target: "41: calculated over", fill: "#a40000"},
{source: "41: calculated over", target: "41: displaystyle", fill: "#a40000"},
{source: "41: global index", target: "START_HERE", fill: "#a40000"}]; 
    // create empty nodes array
    var nodes = {};
	var colorFill = [];
	
    // compute nodes from links data
    links.forEach(function(link) {
        link.source = nodes[link.source] ||
            (nodes[link.source] = {name: link.source});
        link.target = nodes[link.target] ||
            (nodes[link.target] = {name: link.target});
		colorFill.push({name: link.source.name, fill: link.fill });
		colorFill.push({name: link.target.name, fill: link.fill });
    });
	
	console.log(colorFill);


    // add a SVG to the body for our viz
    var svg=d3.select('body').append('svg')
        .attr("viewBox", "0 0 " + width + " " + height );

    // use the force
    var force = d3.layout.force()
		.charge(-5000)
		.gravity(0.3)
        .size([width, height])
        .nodes(d3.values(nodes))
        .links(links)
        .on("tick", tick)
        .linkDistance(200)
        .start();

    // add links
    var link = svg.selectAll('.link')
        .data(links)
        .enter().append('line')
        .attr('class', 'link'); 

    // add nodes
    var node = svg.selectAll('.node')
        .data(force.nodes())
        .enter().append('circle')
        .attr('class', 'node')
        .attr('r', width * 0.0035)
		.style("fill", function(d) {
									for (var i = 0; i < colorFill.length; i++) {
										//console.log(d.name);
										if(colorFill[i].name == d.name){
											console.log(colorFill[i].fill);
											return colorFill[i].fill;
										}
									} return "#555";
									
									});
	var label = svg.selectAll(null)
		.data(force.nodes())
		.enter()
		.append("text")
		.text(function (d) { return d.name; })
		.style("text-anchor", "middle")
		.style("fill", "#555")
		.style("font-family", "Arial")
		.style("font-size", 34);


    // what to do 
    function tick(e) {
        
        node.attr('cx', function(d) { return d.x = Math.max(6, Math.min(width - 6, d.x)); })
            .attr('cy', function(d) { return d.y = Math.max(6, Math.min(height - 6, d.y)); })
            .call(force.drag);
            
        link.attr('x1', function(d) { return d.source.x; })
            .attr('y1', function(d) { return d.source.y; })
            .attr('x2', function(d) { return d.target.x; })
            .attr('y2', function(d) { return d.target.y; });
		
		label.attr("x", function(d){ return d.x; })
             .attr("y", function (d) {return d.y - 10; });
        
    }
    
</script><table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th id='wiki'>Wiki</th>
      <th>Wiki Summary</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><a href="https://en.wikipedia.org/wiki/Pre-topological_order">Pre-topological order</a></td>
      <td>In the field of computer science, a pre-topological order or pre-topological ordering of a directed graph is a linear ordering of its vertices such that if there is a directed path from vertex u to vertex v and v comes before u in the ordering, then there is also a directed path from vertex v to vertex u.\nIf the graph is a directed acyclic graph (DAG), topological orderings are pre-topological orderings and vice versa.</td>
    </tr>
    <tr>
      <td><a href="https://en.wikipedia.org/wiki/Maximum_flow_problem">Maximum flow problem</a></td>
      <td>In optimization theory, maximum flow problems involve finding a feasible flow through a flow network that obtains the maximum possible flow rate.\nThe maximum flow problem can be seen as a special case of more complex network flow problems, such as the circulation problem.</td>
    </tr>
    <tr>
      <td><a href="https://en.wikipedia.org/wiki/Vertex_operator_algebra">Vertex operator algebra</a></td>
      <td>In mathematics, a vertex operator algebra (VOA) is an algebraic structure that plays an important role in two-dimensional conformal field theory and string theory.  In addition to physical applications, vertex operator algebras have proven useful in purely mathematical contexts such as monstrous moonshine and the geometric Langlands correspondence.</td>
    </tr>
    <tr>
      <td><a href="https://en.wikipedia.org/wiki/Time_management">Time management</a></td>
      <td>Time management is the process of planning and exercising conscious control of time spent on specific activities—especially to increase effectiveness, efficiency and productivity.\nTime management involves demands relating to work, social life, family, hobbies, personal interests and commitments.</td>
    </tr>
    <tr>
      <td><a href="https://en.wikipedia.org/wiki/Phoenix_Wright">Phoenix Wright</a></td>
      <td>Phoenix "Nick" Wright, known as Ryūichi Naruhodō (Japanese: 成歩堂 龍一, Hepburn: Naruhodō Ryūichi) in the original Japanese language versions, is the fictional titular defense attorney and the protagonist in Ace Attorney, a visual novel adventure video game series created by Shu Takumi, who was an employee of Japanese gaming company Capcom. Introduced in Phoenix Wright: Ace Attorney (2001), Phoenix is a young rookie attorney who the player controls in several cases to protect the clients suspected of murder.</td>
    </tr>
    <tr>
      <td><a href="https://en.wikipedia.org/wiki/Adjacency_matrix">Adjacency matrix</a></td>
      <td>In graph theory and computer science, an adjacency matrix is a square matrix used to represent a finite graph. The elements of the matrix indicate whether pairs of vertices are adjacent or not in the graph.</td>
    </tr>
    <tr>
      <td><a href="https://en.wikipedia.org/wiki/Tryfan">Tryfan</a></td>
      <td>Tryfan (Welsh pronunciation: [ˈtrəvan]) is a mountain in the Ogwen Valley, Snowdonia, Wales. It forms part of the Glyderau group, and is one of the most recognisable peaks in Britain, having a classic pointed shape with rugged crags.</td>
    </tr>
    <tr>
      <td><a href="https://en.wikipedia.org/wiki/Computer_science">Computer science</a></td>
      <td>Computer science is the study of computation, information, and automation. Computer science spans theoretical disciplines (such as algorithms, theory of computation, and information theory) to applied disciplines (including the design and implementation of hardware and software).</td>
    </tr>
    <tr>
      <td><a href="https://en.wikipedia.org/wiki/Theoretical_computer_science">Theoretical computer science</a></td>
      <td>Theoretical computer science is a subfield of computer science and mathematics that focuses on the abstract and mathematical foundations of computation.\nIt is difficult to circumscribe the theoretical areas precisely.</td>
    </tr>
    <tr>
      <td><a href="https://en.wikipedia.org/wiki/Computer_scientist">Computer scientist</a></td>
      <td>A computer scientist is a scientist who specializes in the academic study of computer science. \nComputer scientists typically work on the theoretical side of computation.</td>
    </tr>
    <tr>
      <td><a href="https://en.wikipedia.org/wiki/Cluster_analysis">Cluster analysis</a></td>
      <td>Cluster analysis or clustering is the task of grouping a set of objects in such a way that objects in the same group (called a cluster) are more similar (in some specific sense defined by the analyst) to each other than to those in other groups (clusters). It is a main task of exploratory data analysis, and a common technique for statistical data analysis, used in many fields, including pattern recognition, image analysis, information retrieval, bioinformatics, data compression, computer graphics and machine learning.</td>
    </tr>
    <tr>
      <td><a href="https://en.wikipedia.org/wiki/Earth_radius">Earth radius</a></td>
      <td>Earth radius (denoted as R🜨 or RE) is the distance from the center of Earth to a point on or near its surface. Approximating the figure of Earth by an Earth spheroid (an oblate ellipsoid), the radius ranges from a maximum (equatorial radius, denoted a) of nearly 6,378 km (3,963 mi) to a minimum (polar radius, denoted b) of nearly 6,357 km (3,950 mi).</td>
    </tr>
    <tr>
      <td><a href="https://en.wikipedia.org/wiki/Grunt_(software)">Grunt (software)</a></td>
      <td>Grunt is a JavaScript task runner, a tool used to automatically perform  frequent tasks such as minification, compilation, unit testing, and linting. It uses a command-line interface to run custom tasks defined in a file (known as a Gruntfile).</td>
    </tr>
    <tr>
      <td><a href="https://en.wikipedia.org/wiki/One,_No_One_and_One_Hundred_Thousand">One, No One and One Hundred Thousand</a></td>
      <td>One, No One and One Hundred Thousand (Italian: Uno, nessuno e centomila [ˈuːno nesˈsuːno e tˌtʃɛntoˈmiːla]) is a 1926 novel by the Italian writer Luigi Pirandello. It is Pirandello's last novel; his son later said that it took "more than 15 years" to write.</td>
    </tr>
    <tr>
      <td><a href="https://en.wikipedia.org/wiki/Content-addressable_network">Content-addressable network</a></td>
      <td>The content-addressable network (CAN) is a distributed, decentralized P2P infrastructure that provides hash table functionality on an Internet-like scale.  CAN was one of the original four distributed hash table proposals, introduced concurrently with Chord, Pastry, and Tapestry.</td>
    </tr>
    <tr>
      <td><a href="https://en.wikipedia.org/wiki/Red–black_tree">Red–black tree</a></td>
      <td>In computer science, a red–black tree is a self-balancing binary search tree data structure noted for fast storage and retrieval of ordered information. The nodes in a red-black tree hold an extra "color" bit, often drawn as red and black, which help ensure that the tree is always approximately balanced.</td>
    </tr>
    <tr>
      <td><a href="https://en.wikipedia.org/wiki/Ł">Ł</a></td>
      <td>Ł or ł,  described in English as L with stroke, is a letter of the Polish, Kashubian, Kurdish, Sorbian, Belarusian Latin, Ukrainian Latin, Wymysorys, Navajo, Dëne Sųłıné, Inupiaq, Zuni, Hupa, Sm'álgyax, Nisga'a, and Dogrib alphabets, several proposed alphabets for the Venetian language, and the ISO 11940 romanization of the Thai script. In some Slavic languages, it represents the continuation of the Proto-Slavic non-palatal ⟨L⟩ (dark L), except in Polish, Kashubian, and Sorbian, where it evolved further into /w/.</td>
    </tr>
    <tr>
      <td><a href="https://en.wikipedia.org/wiki/Not_otherwise_specified">Not otherwise specified</a></td>
      <td>Pervasive developmental disorder not otherwise specified (PDD-NOS) is a historic psychiatric diagnosis first defined in 1980 that has since been incorporated into autism spectrum disorder in the DSM-5 (2013).\nAccording to the earlier DSM-IV, PDD-NOS referred to "mild or severe pervasive deficits in the development of reciprocal social interaction and/or verbal and nonverbal communication skills, or when stereotyped behavior, interests, and/or activities are present, but the criteria are not met for a specific PDD" or for several other disorders.</td>
    </tr>
    <tr>
      <td><a href="https://en.wikipedia.org/wiki/Initial_value_problem">Initial value problem</a></td>
      <td>In multivariable calculus, an initial value problem (IVP) is an ordinary differential equation together with an initial condition which specifies the value of the unknown function at a given point in the domain. Modeling a system in physics or other sciences frequently amounts to solving an initial value problem.</td>
    </tr>
    <tr>
      <td><a href="https://en.wikipedia.org/wiki/Classical_Chinese">Classical Chinese</a></td>
      <td>Classical Chinese is the language in which the classics of Chinese literature were written, from c. the 5th century BCE. For millennia thereafter, the written Chinese used in these works was imitated and iterated upon by scholars in a form now called Literary Chinese, which was used for almost all formal writing in China until the early 20th century. Each written character corresponds to a single spoken syllable, and almost always to a single independent word.</td>
    </tr>
    <tr>
      <td><a href="https://en.wikipedia.org/wiki/Graph_drawing">Graph drawing</a></td>
      <td>Graph drawing is an area of mathematics and computer science combining methods from geometric graph theory and information visualization to derive two-dimensional depictions of graphs arising from applications such as social network analysis, cartography, linguistics, and bioinformatics.\nA drawing of a graph or network diagram is a pictorial representation of the vertices and edges of a graph.</td>
    </tr>
    <tr>
      <td><a href="https://en.wikipedia.org/wiki/Personal_knowledge_base">Personal knowledge base</a></td>
      <td>A personal knowledge base (PKB) is an electronic tool used by an individual to express, capture, and later retrieve personal knowledge. It differs from a traditional database in that it contains subjective material particular to the owner, that others may not agree with nor care about.</td>
    </tr>
    <tr>
      <td><a href="https://en.wikipedia.org/wiki/Rete_algorithm">Rete algorithm</a></td>
      <td>The Rete algorithm ( REE-tee,  RAY-tee, rarely  REET,  reh-TAY) is a pattern matching algorithm for implementing rule-based systems. The algorithm was developed to efficiently apply many rules or patterns to many objects, or facts, in a knowledge base.</td>
    </tr>
    <tr>
      <td><a href="https://en.wikipedia.org/wiki/Ford–Fulkerson_algorithm">Ford–Fulkerson algorithm</a></td>
      <td>The Ford–Fulkerson method or Ford–Fulkerson algorithm (FFA) is a greedy algorithm that computes the maximum flow in a flow network. It is sometimes called a "method" instead of an "algorithm" as the approach to finding augmenting paths in a residual graph is not fully specified or it is specified in several implementations with different running times.</td>
    </tr>
    <tr>
      <td><a href="https://en.wikipedia.org/wiki/Semiconductor_device_fabrication">Semiconductor device fabrication</a></td>
      <td>Semiconductor device fabrication is the process used to manufacture semiconductor devices, typically integrated circuits (ICs) such as microprocessors, microcontrollers, and memories (such as RAM and flash memory). It is a multiple-step photolithographic and physico-chemical process (with steps such as thermal oxidation, thin-film deposition, ion-implantation, etching) during which electronic circuits are gradually created on a wafer, typically made of pure single-crystal semiconducting material.</td>
    </tr>
    <tr>
      <td><a href="https://en.wikipedia.org/wiki/Grammy_Award_for_Best_Song_Written_for_Visual_Media">Grammy Award for Best Song Written for Visual Media</a></td>
      <td>The Grammy Award for Best Song Written for Visual Media (including its previous names) is the Grammy Awards awarded to songs written for films, television, video games or other visual media.\n\n\n== Recipients ==\n\n^[I]  Each year is linked to the article about the Grammy Awards held that year.</td>
    </tr>
    <tr>
      <td><a href="https://en.wikipedia.org/wiki/Diameter_(graph_theory)">Diameter (graph theory)</a></td>
      <td>In graph theory, the diameter of a connected undirected graph is the farthest distance between any two of its vertices. That is, it is the diameter of a set for the set of vertices of the graph, and for the shortest-path distance in the graph.</td>
    </tr>
    <tr>
      <td><a href="https://en.wikipedia.org/wiki/Matrix_(mathematics)">Matrix (mathematics)</a></td>
      <td>In mathematics, a matrix (pl.: matrices) is a rectangular array or table of numbers, symbols, or expressions, with elements or entries arranged in rows and columns, which is used to represent a mathematical object or property of such an object.\nFor example, \n\n  \n    \n      \n        \n          \n            [\n            \n              \n                \n                  1\n                \n                \n                  9\n                \n                \n                  −\n                  13\n                \n              \n              \n                \n                  20\n                \n                \n                  5\n                \n                \n                  −\n                  6\n                \n              \n            \n            ]\n          \n        \n      \n    \n    {\displaystyle {\begin{bmatrix}1&amp;9&amp;-13\\20&amp;5&amp;-6\end{bmatrix}}}\n  \n\nis a matrix with two rows and three columns.</td>
    </tr>
    <tr>
      <td><a href="https://en.wikipedia.org/wiki/South_West_Coast_Path">South West Coast Path</a></td>
      <td>The South West Coast Path is England's longest waymarked long-distance footpath and a National Trail. It stretches for 630 miles (1,014 km), running from Minehead in Somerset, along the coasts of Devon and Cornwall, to Poole Harbour in Dorset.</td>
    </tr>
    <tr>
      <td><a href="https://en.wikipedia.org/wiki/List_of_Internet_pioneers">List of Internet pioneers</a></td>
      <td>Instead of having a single inventor, the Internet was developed by many people over many years. The following people are Internet pioneers who have been recognized for their contribution to its early and ongoing development.</td>
    </tr>
    <tr>
      <td><a href="https://en.wikipedia.org/wiki/Zero-based_numbering">Zero-based numbering</a></td>
      <td>Zero-based numbering is a way of numbering in which the initial element of a sequence is assigned the index 0, rather than the index 1 as is typical in everyday non-mathematical or non-programming circumstances. Under zero-based numbering, the initial element is sometimes termed the zeroth element, rather than the first element; zeroth is a coined ordinal number corresponding to the number zero.</td>
    </tr>
    <tr>
      <td><a href="https://en.wikipedia.org/wiki/Iterator">Iterator</a></td>
      <td>In computer programming, an iterator is an object that progressively provides access to each item of a collection, in order. \nA collection may provide multiple iterators via its interface that provide items in different orders, such as forwards and backwards.</td>
    </tr>
    <tr>
      <td><a href="https://en.wikipedia.org/wiki/Rayleigh_quotient_iteration">Rayleigh quotient iteration</a></td>
      <td>Rayleigh quotient iteration is an eigenvalue algorithm which extends the idea of the inverse iteration by using the Rayleigh quotient to obtain increasingly accurate eigenvalue estimates.\nRayleigh quotient iteration is an iterative method, that is, it delivers a sequence of approximate solutions that converges to a true solution in the limit.</td>
    </tr>
    <tr>
      <td><a href="https://en.wikipedia.org/wiki/Load_balancing_(computing)">Load balancing (computing)</a></td>
      <td>In computing, load balancing is the process of distributing a set of tasks over a set of resources (computing units), with the aim of making their overall processing more efficient. Load balancing can optimize response time and avoid unevenly overloading some compute nodes while other compute nodes are left idle.</td>
    </tr>
  </tbody>
</table><table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th id='risk_factors'>Sentences</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><font color="blue">Topological </font>sortingContributors to Wikimedia projects1621 minutesIn computer science, a topological sort or <font color="blue">topological ordering</font> of a <font color="blue">directed graph</font> is a <font color="blue">linear ordering</font> of its vertices such that for every directed edge (u,v) from vertex u to vertex v, u comes before v in the ordering</td>
    </tr>
    <tr>
      <td>For instance, the vertices of the <font color="blue">graph may represent tasks</font> to be performed, and the <font color="blue">edges may represent constraints</font> that <font color="blue">one task must</font> be performed before another; in this <font color="blue">application</font>, a <font color="blue">topological ordering</font> is just a <font color="blue">valid sequence</font> for the tasks</td>
    </tr>
    <tr>
      <td>Precisely, a topological sort is a graph traversal in which each node v is visited only after all its <font color="blue">dependencies</font> are visited</td>
    </tr>
    <tr>
      <td>A <font color="blue">topological ordering</font> is possible if and only if the graph has <font color="blue">no directed cycles</font>, that is, if it is a <font color="blue">directed acyclic graph</font> (DAG)</td>
    </tr>
    <tr>
      <td>Any DAG has at least one <font color="blue">topological ordering</font>, and <font color="blue">algorithms</font> are known for <font color="blue">constructing</font> a <font color="blue">topological ordering</font> of any DAG in linear time</td>
    </tr>
    <tr>
      <td><font color="blue">Topological </font>sorting has many <font color="blue">application</font>s, especially in <font color="blue">ranking problems such as feedback arc set</font></td>
    </tr>
    <tr>
      <td><font color="blue">Topological </font>sorting is <font color="blue">also possible</font> when the DAG has <font color="blue">disconnected components</font></td>
    </tr>
    <tr>
      <td>This graph has many <font color="blue">valid topological sorts</font>, including:    5, 7, 3, 11, 8, 2, 9, 10 (visual left-to-right, top-to-bottom)    3, 5, 7, 8, 11, 2, 9, 10 (smallest-numbered available vertex first)    3, 5, 7, 8, 11, 2, 10, 9 (lexicographic by incoming neighbors)    5, 7, 3, 8, 11, 2, 10, 9 (fewest edges first)    7, 5, 11, 3, 10, 8, 9, 2 (largest-numbered available vertex first)    5, 7, 11, 2, 3, 8, 9, 10 (attempting top-to-bottom, left-to-right)    3, 7, 8, 5, 11, 10, 2, 9 (<font color="blue">arbitrary</font>)The canonical <font color="blue">application</font> of <font color="blue">topological sorting</font> is in scheduling a sequence of jobs or <font color="blue">tasks based on</font> their <font color="blue">dependencies</font></td>
    </tr>
    <tr>
      <td>The jobs are <font color="blue">represented by vertices</font>, and there is an <font color="blue">edge from x</font> to y if <font color="blue">job x must</font> be completed before job y can be started (for example, when washing clothes, the washing machine must finish before we put the clothes in the dryer)</td>
    </tr>
    <tr>
      <td>A closely-related <font color="blue">application</font> of <font color="blue">topological sorting</font> <font color="blue">algorithms</font> was <font color="blue">first studied</font> in the early 1960s in the context of the PERT technique for scheduling in project <font color="blue">management</font></td>
    </tr>
    <tr>
      <td>[1] In this <font color="blue">application</font>, the vertices of a <font color="blue">graph represent</font> the <font color="blue">milestones</font> of a project, and the <font color="blue">edges represent tasks</font> that must be performed <font color="blue">between one milestone</font> and another</td>
    </tr>
    <tr>
      <td><font color="blue">Topological </font><font color="blue">sorting forms</font> the basis of linear-time <font color="blue">algorithms</font> for finding the <font color="blue">critical path</font> of the project, a sequence of <font color="blue">milestones</font> and tasks that controls the length of the overall project schedule</td>
    </tr>
    <tr>
      <td>In computer science, <font color="blue">application</font>s of this type arise in instruction scheduling, ordering of <font color="blue">formula cell evaluation</font> when <font color="blue">recomputing formula values</font> in spreadsheets, logic synthesis, determining the order of <font color="blue">compilation tasks</font> to perform in makefiles, data serialization, and resolving symbol <font color="blue">dependencies</font> in linkers</td>
    </tr>
    <tr>
      <td>It is also used to decide in which order to <font color="blue">load tables with foreign keys</font> in <font color="blue">databases</font></td>
    </tr>
    <tr>
      <td>The usual <font color="blue">algorithms</font> for <font color="blue">topological sorting</font> have running time linear in the number of <font color="blue">nodes plus</font> the number of edges, asymptotically, {\<font color="blue">displaystyle</font> O(\left|{V}\right|+\left|{E}\right|)</td>
    </tr>
    <tr>
      <td>}One of these <font color="blue">algorithms</font>, first described by Kahn (1962), works <font color="blue">by choosing vertices</font> in the same order as the <font color="blue">eventual topological</font> sort</td>
    </tr>
    <tr>
      <td>[2] First, find a list of  &amp;quote start nodes &amp;quote  that have <font color="blue">no incoming edges</font> and <font color="blue">insert them into</font> a set S; <font color="blue">at least one such node must</font> exist in a non-empty (finite) acyclic graph</td>
    </tr>
    <tr>
      <td>Then:L  Empty list that <font color="blue">will contain</font> the sorted elementsS  Set of all nodes with no incoming edgewhile S is not empty do    remove a <font color="blue">node n from</font> S    add n to L    for <font color="blue">each node m with</font> an edge e from n to m do        remove edge e from the graph        if m has no other <font color="blue">incoming <font color="blue">edges then</font></font>            <font color="blue">insert m into</font> Sif graph has <font color="blue">edges then</font>    return error   (graph has <font color="blue">at least one cycle</font>)else     return L   (a <font color="blue">topologically</font> sorted order)If the graph is a DAG, a solution will be contained in the list L (although the solution is not <font color="blue">necessarily unique</font>)</td>
    </tr>
    <tr>
      <td>Otherwise, the graph must have <font color="blue">at least one cycle</font> and therefore a topological sort is impossible</td>
    </tr>
    <tr>
      <td><font color="blue">Reflecting </font>the non-uniqueness of the resulting sort, the structure S can be simply a set or a queue or a stack</td>
    </tr>
    <tr>
      <td><font color="blue">Depending </font>on the order that nodes n are <font color="blue">removed from set</font> S, a <font color="blue">different</font> solution is created</td>
    </tr>
    <tr>
      <td>A variation of Kahnapstas algorithm that <font color="blue">breaks ties lexicographically forms</font> a key component of the <font color="blue">CoffmanGraham </font>algorithm for <font color="blue">parallel scheduling</font> and <font color="blue">layered graph drawing</font></td>
    </tr>
    <tr>
      <td>An <font color="blue">alternative algorithm</font> for <font color="blue">topological sorting</font> is based on depth-first search</td>
    </tr>
    <tr>
      <td>The <font color="blue">algorithm loops through each node</font> of the graph, in an <font color="blue">arbitrary</font> order, initiating a depth-first search that terminates when it hits any node that has <font color="blue">already been visited since</font> the beginning of the topological sort or the node has no outgoing edges (ie, a leaf node):L  Empty list that <font color="blue">will contain</font> the sorted nodeswhile exists <font color="blue">nodes without</font> a permanent mark do    select an <font color="blue">unmarked node n</font>    visit(n)function visit(node n)    if n has a permanent mark then        return    if n has a temporary mark then        stop   (graph has <font color="blue">at least one cycle</font>)    mark n with a temporary mark    for <font color="blue">each node m with</font> an <font color="blue">edge from n</font> to m do        visit(m)    mark n with a permanent mark    add n to head of LEach node n gets prepended to the <font color="blue">output list</font> L only after considering all other nodes that <font color="blue">depend on n</font> (all <font color="blue">descendants</font> of n in the graph)</td>
    </tr>
    <tr>
      <td>Specifically, when the <font color="blue">algorithm adds node n</font>, we are guaranteed that all nodes that <font color="blue">depend on n</font> are already in the <font color="blue">output list</font> L: they were added to L <font color="blue">either by</font> the <font color="blue">recursive call</font> to visit() that ended before the call to visit n, or by a call to visit() that <font color="blue">started even</font> before the call to visit n</td>
    </tr>
    <tr>
      <td>Since each edge and node is <font color="blue">visited once</font>, the <font color="blue">algorithm runs</font> in linear time</td>
    </tr>
    <tr>
      <td>This depth-first-search-based algorithm is the <font color="blue">one described by</font> Cormen et al</td>
    </tr>
    <tr>
      <td>(2001);[3] it seems to have <font color="blue">been first described</font> in print by Tarjan in 1976</td>
    </tr>
    <tr>
      <td>[4]On a parallel random-access machine, a <font color="blue">topological ordering</font> can be <font color="blue">constructed</font> in O((log n)2) time using a polynomial number of processors, putting the <font color="blue">problem into</font> the <font color="blue">complexity</font> class NC2</td>
    </tr>
    <tr>
      <td>[5] One method for doing this is to <font color="blue">repeatedly square</font> the <font color="blue">adjacency matrix</font> of the given graph, logarithmically many times, using min-plus matrix multiplication with maximization in place of <font color="blue">minimization</font></td>
    </tr>
    <tr>
      <td>The resulting <font color="blue">matrix describes</font> the <font color="blue"><font color="blue">longest path</font> distances</font> in the graph</td>
    </tr>
    <tr>
      <td>[6]An algorithm for parallel <font color="blue">topological sorting</font> on distributed memory machines parallelizes the algorithm of <font color="blue">Kahn for a DAG </font>{\<font color="blue">displaystyle</font> G=(V,E)}</td>
    </tr>
    <tr>
      <td>[7] On a high level, the algorithm of Kahn <font color="blue">repeatedly removes</font> the vertices of indegree 0 and adds them to the <font color="blue">topological sorting</font> in the order in which they were removed</td>
    </tr>
    <tr>
      <td>Since the outgoing edges of the <font color="blue">removed vertices</font> are also removed, there will be a new set of vertices of indegree 0, where the procedure is repeated <font color="blue">until no vertices</font> are left</td>
    </tr>
    <tr>
      <td>This algorithm performs {\<font color="blue">displaystyle</font> D+1} iterations, where D is the <font color="blue">longest path</font> in G Each iteration can be parallelized, which is the idea of the <font color="blue">following algorithm</font></td>
    </tr>
    <tr>
      <td>Each PE i <font color="blue">initializes</font> a set of local vertices {\<font color="blue">displaystyle</font> Q_{i}^{1}} with indegree 0, where the <font color="blue">upper index represents</font> the <font color="blue">current iteration</font></td>
    </tr>
    <tr>
      <td>Since all vertices in the local sets {\<font color="blue">displaystyle</font> Q_{0}^{1},\dots ,Q_{p-1}^{1}} have indegree 0, ie, they are not <font color="blue">adjacent</font>, they can be given in an <font color="blue">arbitrary</font> order for a valid <font color="blue">topological sorting</font></td>
    </tr>
    <tr>
      <td>To assign a <font color="blue">global index</font> to <font color="blue">each vertex</font>, a <font color="blue">prefix sum</font> is <font color="blue">calculated over</font> the sizes of {\<font color="blue">displaystyle</font> Q_{0}^{1},\dots ,Q_{p-1}^{1}}</td>
    </tr>
    <tr>
      <td>So, each step, there are {\textstyle \sum _{i=0}^{p-1}|Q_{i}|} vertices added to the <font color="blue">topological sorting</font></td>
    </tr>
  </tbody>
</table></body>


</html>